#!/usr/bin/env node

var url = require('url');
var util = require('util');
var argv = require('optimist').argv;
var tilelive = require('..');

require('mbtiles').registerProtocols(tilelive);
require('tilejson').registerProtocols(tilelive);

var commands = {
    'copy': '[from] [to] --bbox="[bbox]" --zoom=0-4 --concurrency=100'
};

function lpad(str, len, chr) {
    if (!chr) chr = ' ';
    str = String(str);
    len = Math.max(0, len - str.length + 1);
    return Array(len).join(chr) + str;
}

function formatHMS(ms) {
    var seconds = ms / 1000 | 0;
    var hours = (seconds / 3600) | 0;
    seconds -= hours * 3600;
    var minutes = (seconds / 60) | 0;
    seconds -= minutes * 60;
    return lpad(hours, 2, '0') + ':' + lpad(minutes, 2, '0') + ':' + lpad(seconds, 2, '0');
}

switch (argv._[0]) {
    case 'copy':
        // if (!argv._[1]) usage();
        var from = url.parse(argv._[1] || '');
        if (!from.protocol) usage('Invalid from protocol: ' + argv._[1]);

        var to = url.parse(argv._[2] || '');
        if (!to.protocol) usage('Invalid to protocol: ' + argv._[2]);

        var bbox = String(argv.bbox || '-180,-90,180,90').split(/\s*[, ]\s*/).map(parseFloat);
        if (bbox.length !== 4) usage('Invalid bounding box: ' + util.inspect(argv.bbox));

        var zoom = String(argv.zoom || 0).split(/\s*[,-]\s*/).map(parseFloat);
        if (zoom.length === 1) zoom[1] = zoom[0];
        if (zoom.length != 2 || isNaN(zoom[0]) || isNaN(zoom[1])) usage('Invalid zoom range: ' + util.inspect(argv.zoom));

        var concurrency = parseInt(argv.concurrency || 100, 10);
        if (isNaN(concurrency)) usage('Invalid concurrency: ' + util.inspect(argv.concurrency));

        console.warn('Starting...');
        console.warn('         from: %s', url.format(from));
        console.warn('           to: %s', url.format(to));
        console.warn('         bbox: %s', util.inspect(bbox));
        console.warn('         zoom: %s', util.inspect(zoom));
        console.warn('  concurrency: %s', util.inspect(concurrency));

        tilelive.load(from, function(err, source) {
            if (err) throw err;
            tilelive.load(to, function(err, sink) {
                if (err) throw err;

                var copy = tilelive.copy(source, sink, bbox, zoom[0], zoom[1], concurrency);
                copy.notFound = 0;

                console.warn('');
                console.warn('|0% --------- 50% -------- 100%|  done |   copied |   failed |    total |   speed |  elapsed |   ETA in');
                           // |==============================| 50.3% | 00000000 | 00000000 | 200.0/s | 00:00:00 | 00:09:04

                var spinner = '-\\|/', spinnerPos = 3;
                var lastProgress = 0;
                function progress() {
                    var progress = (copy.copied + copy.failed) / copy.total;
                    if (progress >= 1) return;
                    util.print('\r|');
                    var bits = Math.floor(progress * 30) + 1;
                    util.print(Array(bits).join('='));
                    util.print(spinner[spinnerPos = (spinnerPos + 1) % 4]);
                    util.print(Array(31 - bits).join(' '));
                    util.print('| ');
                    util.print(lpad((progress * 100).toFixed(1), 4));
                    util.print('% | ');
                    util.print(lpad(copy.copied, 8));
                    util.print(' | ');
                    util.print(lpad(copy.failed, 8));
                    util.print(' | ');
                    util.print(lpad(copy.total, 8));
                    util.print(' | ');
                    var speed = copy.copied + copy.failed - lastProgress;
                    if (speed >= 1000) util.print(lpad(speed.toFixed(0), 5));
                    else util.print(lpad(speed.toFixed(1), 5));
                    util.print('/s | ');
                    util.print(formatHMS(Date.now() - copy.started));
                    util.print(' | ');
                    var remaining = (Date.now() - copy.started) / (copy.copied + copy.failed) * (copy.total - copy.copied - copy.failed);
                    util.print(formatHMS(remaining));
                    lastProgress = copy.copied + copy.failed;
                }

                var timeout = setInterval(progress, 1000);
                progress();

                copy.on('warning', function(err) {
                    if (err.message === 'Tile does not exist') copy.notFound++;
                });

                var finished = false;
                copy.on('finished', function() {
                    clearTimeout(timeout);
                    finished = true;
                    process.exit();
                });
                copy.on('error', function(err) {
                    clearTimeout(timeout);
                    console.warn(err);
                });

                function exit() {
                    console.warn('');
                    console.warn(finished ? 'Finished.' : 'Aborted.');
                    console.warn('       copied: %d', copy.copied);
                    console.warn('       failed: %d (%d not found)', copy.failed, copy.notFound);
                    console.warn('     duration: %s', formatHMS(Date.now() - copy.started));
                    console.warn('    avg speed: %d tiles/s', ((copy.copied + copy.failed) / (Date.now() - copy.started) * 1000).toFixed(1));
                }
                process.on('exit', exit).on('SIGINT', process.exit);
            });
        });

        break;
    default:
        usage();
}

function usage(msg) {
    if (msg) console.warn(msg);
    if (commands[argv._[0]]) {
        console.warn('Usage: %s %s %s', argv.$0, argv._[0], commands[argv._[0]]);
    } else {
        console.warn('Usage: %s [command]', argv.$0);
        console.warn('Commands:');
        for (var cmd in commands) {
            console.warn('    %s %s', cmd, commands[cmd]);
        }
    }
    process.exit(1);
}